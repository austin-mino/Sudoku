<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku Pro with Memo & Lives</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    :root {
      --bg: #0e1014;
      --card: #1c1f26;
      --accent: #4f9eff;
      --text: #e2e2e2;
      --danger: #ff6b6b;
      --radius: 10px;
    }
    body.light {
      --bg: #f4f4f4;
      --card: #ffffff;
      --text: #222;
    }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      user-select: none;
    }
    h1 {
      margin: 0 0 1rem;
      color: var(--accent);
    }
    #controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    button, select {
      background: var(--accent);
      border: none;
      color: #fff;
      padding: 8px 14px;
      border-radius: var(--radius);
      font-weight: 600;
      cursor: pointer;
    }
    button:hover {
      background: #3a8ce0;
    }
    #timer {
      font-weight: 600;
    }
    #lives {
      font-weight: 600;
      margin-left: 10px;
      color: var(--danger);
    }
    #noteToggle {
      background: #ffb142;
      color: black;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
    }
    .cell {
      position: relative;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--card);
      font-size: 1.4rem;
      cursor: pointer;
      user-select: none;
      box-sizing: border-box;
      border: 1px solid #444;
    }
    .cell.prefill {
      background: #282c34;
      font-weight: 700;
      cursor: default;
      color: #ccc;
    }
    .cell.invalid {
      color: var(--danger);
      font-weight: 700;
    }
    .cell.selected {
      outline: 2px solid var(--accent);
      z-index: 1;
    }
    .border-top {
      border-top: 2px solid var(--accent) !important;
    }
    .border-left {
      border-left: 2px solid var(--accent) !important;
    }
    .border-right {
      border-right: 2px solid var(--accent) !important;
    }
    .border-bottom {
      border-bottom: 2px solid var(--accent) !important;
    }
    /* 메모 스타일 */
    .notes {
      position: absolute;
      top: 3px;
      left: 3px;
      right: 3px;
      bottom: 3px;
      font-size: 0.5rem;
      color: #888;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      user-select: none;
      pointer-events: none;
    }
    .notes div {
      text-align: center;
      line-height: 1;
      padding: 0;
      margin: 0;
      user-select: none;
    }
  </style>
</head>
<body>
  <h1>Sudoku Pro</h1>
  <div id="controls">
    <select id="difficulty">
      <option value="easy">쉬움</option>
      <option value="medium">보통</option>
      <option value="hard">어려움</option>
    </select>
    <button id="newGameBtn">새 게임</button>
    <button id="hintBtn"><i class="fa-solid fa-lightbulb"></i> 힌트</button>
    <button id="noteToggle">메모 모드 OFF</button>
    <button id="themeToggle"><i class="fa-solid fa-circle-half-stroke"></i></button>
    <span id="hintCount"></span>
    <span id="lives">목숨: 3</span>
    <span id="timer">00:00</span>
  </div>

  <div id="board"></div>

  <div id="keypad">
    <button class="key" data-key="1">1</button>
    <button class="key" data-key="2">2</button>
    <button class="key" data-key="3">3</button>
    <button class="key" data-key="4">4</button>
    <button class="key" data-key="5">5</button>
    <button class="key" data-key="6">6</button>
    <button class="key" data-key="7">7</button>
    <button class="key" data-key="8">8</button>
    <button class="key" data-key="9">9</button>
    <button class="key" data-key="0">지우기</button>
  </div>

  <script>
    const deepCopy = m => m.map(r => r.slice());

    function isValid(board, row, col, num) {
      for (let i = 0; i < 9; i++) {
        if ((i !== col && board[row][i] === num) || (i !== row && board[i][col] === num)) return false;
      }
      const sr = Math.floor(row / 3) * 3, sc = Math.floor(col / 3) * 3;
      for (let r = sr; r < sr + 3; r++) {
        for (let c = sc; c < sc + 3; c++) {
          if ((r !== row || c !== col) && board[r][c] === num) return false;
        }
      }
      return true;
    }

    function solve(board) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) {
            for (let n = 1; n <= 9; n++) {
              if (isValid(board, r, c, n)) {
                board[r][c] = n;
                if (solve(board)) return true;
                board[r][c] = 0;
              }
            }
            return false;
          }
        }
      }
      return true;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function generateFullBoard() {
      const board = Array.from({ length: 9 }, () => Array(9).fill(0));
      const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      function fill(r = 0, c = 0) {
        if (r === 9) return true;
        const [nr, nc] = c === 8 ? [r + 1, 0] : [r, c + 1];
        for (const n of shuffle(nums)) {
          if (isValid(board, r, c, n)) {
            board[r][c] = n;
            if (fill(nr, nc)) return true;
            board[r][c] = 0;
          }
        }
        return false;
      }
      fill();
      return board;
    }

    function makePuzzle(fullBoard, difficulty) {
      const puzzle = deepCopy(fullBoard);
      let attempts = difficulty === 'easy' ? 35 : difficulty === 'medium' ? 45 : 55;
      while (attempts > 0) {
        const r = Math.floor(Math.random() * 9);
        const c = Math.floor(Math.random() * 9);
        if (puzzle[r][c] !== 0) {
          const backup = puzzle[r][c];
          puzzle[r][c] = 0;
          const copy = deepCopy(puzzle);
          if (!solve(copy)) puzzle[r][c] = backup;
          else attempts--;
        }
      }
      return puzzle;
    }

    // 상태 변수
    const boardEl = document.getElementById('board');
    const difficultySelect = document.getElementById('difficulty');
    const hintCountEl = document.getElementById('hintCount');
    const livesEl = document.getElementById('lives');
    let puzzle = [], solution = [], prefillCells = new Set(), selected = null;
    let notes = Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => new Set()));
    let timerInt, startTime, hintLimit = 0, hintUsed = 0;
    let lives = 3;
    let isNoteMode = false;

    // 보드 그리기
    function drawBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (r % 3 === 0) cell.classList.add('border-top');
          if (c % 3 === 0) cell.classList.add('border-left');
          if (r === 8) cell.classList.add('border-bottom');
          if (c === 8) cell.classList.add('border-right');

          const key = `${r}-${c}`;
          if (selected && selected.r === r && selected.c === c) {
            cell.classList.add('selected');
          }

          if (puzzle[r][c] !== 0) {
            cell.textContent = puzzle[r][c];
            if (prefillCells.has(key)) {
              cell.classList.add('prefill');
            }
            if (!isValid(puzzle, r, c, puzzle[r][c])) {
              cell.classList.add('invalid');
            }
          } else if (notes[r][c].size > 0) {
            // 메모 표시
            const notesDiv = document.createElement('div');
            notesDiv.className = 'notes';
            for (let n = 1; n <= 9; n++) {
              const noteCell = document.createElement('div');
              if (notes[r][c].has(n)) {
                noteCell.textContent = n;
              } else {
                noteCell.textContent = '';
              }
              notesDiv.appendChild(noteCell);
            }
            cell.appendChild(notesDiv);
          }

          cell.dataset.pos = key;
          if (!prefillCells.has(key)) {
            cell.onclick = () => selectCell(r, c);
          }

          boardEl.appendChild(cell);
        }
      }
    }

    // 셀 선택
    function selectCell(r, c) {
      if (prefillCells.has(`${r}-${c}`)) return;
      selected = { r, c };
      drawBoard();
    }

    // 입력 처리 (키보드 및 키패드)
    function inputNumber(num) {
      if (!selected) return;
      const { r, c } = selected;
      if (prefillCells.has(`${r}-${c}`)) return;

      if (isNoteMode) {
        // 노트 모드: 메모 토글
        if (num === 0) {
          notes[r][c].clear();
        } else {
          if (notes[r][c].has(num)) {
            notes[r][c].delete(num);
          } else {
            notes[r][c].add(num);
          }
        }
      } else {
        // 일반 모드: 숫자 입력 & 검증
        if (num === 0) {
          puzzle[r][c] = 0;
        } else {
          puzzle[r][c] = num;
          if (!isValid(puzzle, r, c, num)) {
            // 오답 => 목숨 차감
            lives--;
            updateLives();
            if (lives <= 0) {
              alert('목숨이 모두 소진되었습니다! 게임 오버');
              clearInterval(timerInt);
              disableAllInput();
            }
          }
          notes[r][c].clear(); // 입력하면 메모 초기화
        }
      }
      validate();
      drawBoard();
      checkWin();
    }

    // 목숨 표시 업데이트
    function updateLives() {
      livesEl.textContent = `목숨: ${lives}`;
      livesEl.style.color = lives <= 1 ? 'var(--danger)' : 'inherit';
    }

    // 입력 비활성화 (게임 오버 시)
    function disableAllInput() {
      selected = null;
      // 클릭 불가하도록 셀 클릭 제거
      for (const cell of boardEl.children) {
        cell.onclick = null;
      }
      // 키패드 버튼 비활성화
      document.querySelectorAll('.key').forEach(btn => btn.disabled = true);
      // 노트 토글 비활성화
      document.getElementById('noteToggle').disabled = true;
      // 힌트 버튼 비활성화
      document.getElementById('hintBtn').disabled = true;
    }

    // 입력(키보드)
    function handleKeyDown(e) {
      if (!selected) return;
      if (e.key >= '1' && e.key <= '9') {
        inputNumber(parseInt(e.key));
      } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
        inputNumber(0);
      }
    }

    // 퍼즐 검증
    function validate() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          // 검증은 drawBoard에서 처리함 (클래스 토글)
        }
      }
    }

    // 타이머
    const timerEl = document.getElementById('timer');
    function startTimer() {
      startTime = Date.now();
      clearInterval(timerInt);
      timerInt = setInterval(() => {
        const diff = Math.floor((Date.now() - startTime) / 1000);
        const m = String(Math.floor(diff / 60)).padStart(2, '0');
        const s = String(diff % 60).padStart(2, '0');
        timerEl.textContent = `${m}:${s}`;
      }, 1000);
    }

    // 새 게임
    function newGame() {
      const full = generateFullBoard();
      solution = deepCopy(full);
      puzzle = makePuzzle(full, difficultySelect.value);
      prefillCells = new Set();
      hintUsed = 0;
      lives = 3;
      updateLives();
      isNoteMode = false;
      document.getElementById('noteToggle').textContent = '메모 모드 OFF';
      hintLimit = difficultySelect.value === 'easy' ? 5 : difficultySelect.value === 'medium' ? 3 : 1;
      hintCountEl.textContent = `힌트: ${hintUsed}/${hintLimit}`;
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (puzzle[r][c] !== 0) prefillCells.add(`${r}-${c}`);
          notes[r][c].clear();
        }
      }
      selected = null;
      drawBoard();
      validate();
      startTimer();

      // 재활성화
      document.querySelectorAll('.key').forEach(btn => btn.disabled = false);
      document.getElementById('noteToggle').disabled = false;
      document.getElementById('hintBtn').disabled = false;
    }

    // 힌트 보여주기
    function showHint() {
      if (hintUsed >= hintLimit) {
        alert("힌트를 모두 사용했습니다!");
        return;
      }
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (puzzle[r][c] === 0) {
            puzzle[r][c] = solution[r][c];
            hintUsed++;
            hintCountEl.textContent = `힌트: ${hintUsed}/${hintLimit}`;
            drawBoard();
            validate();
            checkWin();
            return;
          }
        }
      }
    }

    // 완성 체크
    function checkWin() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (puzzle[r][c] !== solution[r][c]) return;
        }
      }
      clearInterval(timerInt);
      alert("🎉 축하합니다! 퍼즐을 완료했습니다.");
      selected = null;
      drawBoard();
    }

    // 이벤트 바인딩
    document.getElementById('newGameBtn').onclick = newGame;
    document.getElementById('hintBtn').onclick = showHint;
    document.getElementById('noteToggle').onclick = () => {
      isNoteMode = !isNoteMode;
      document.getElementById('noteToggle').textContent = isNoteMode ? '메모 모드 ON' : '메모 모드 OFF';
    };
    document.getElementBy
